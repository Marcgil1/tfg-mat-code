#! /Users/marcgile/miniforge3/bin/python
#! /usr/bin/python
import argparse
import csv
import logging
import math
import pathlib
import sys
import timeit

import amplpy
import numpy             as np
import matplotlib.pyplot as plt

from rich.logging  import RichHandler
from rich.progress import Progress

AMPL_PATH  = '/Users/marcgile/SourceProgs/ampl/ampl'
TIME_LIMIT = 600.0

models = {
    'sll':   ['ampl/sll1.mod',   'ampl/sll2.mod'  ],
    'efsll': ['ampl/efsll1.mod', 'ampl/efsll2.mod'],
}

latex_model_name = {
    'sll1':   '\ensuremath{\mathbf{(SLL}_1\mathbf{)}}',
    'sll2':   '\ensuremath{\mathbf{(SLL}_2\mathbf{)}}',
    'efsll1': '\ensuremath{\mathbf{(EF-SLL}_1\mathbf{)}}',
    'efsll2': '\ensuremath{\mathbf{(EF-SLL}_2\mathbf{)}}',
}

numinstances  =   3
numsitems     = [ 5, 15, 25]
percpreferred = [10, 25, 50]

def getampl():
    amplpy.add_to_path(AMPL_PATH)
    ampl = amplpy.AMPL()
    ampl.option['solver'      ] = 'cplex'
    ampl.option['solver_msg'  ] = '0'
    ampl.option['cplex_option'] = 'timelimit=%.1f' % TIME_LIMIT
    return ampl

def parseargs():
    parser = argparse.ArgumentParser()
    parser.add_argument('-f', '--form',    default='efsll')
    parser.add_argument('-d', '--datadir', default='01')
    args = parser.parse_args()

    return args.form, args.datadir

def getdata(log, form, datadir):
    datapath = pathlib.Path('data') / form / datadir
    if not datapath.is_dir():
        sys.exit(1)

    instances = {}
    for numitems in numsitems:
        numitemspath = datapath / ("%2d" % numitems)
        if not numitemspath.is_dir():
            sys.exit(1)
        
        instances[numitems] = {}
        for perc in percpreferred:
            percpath = numitemspath / ("%2d" % perc)
            if not percpath.is_dir():
                sys.exit(1)

            instances[numitems][perc] = []
            for instance in percpath.iterdir():
                instances[numitems][perc] += [
                    str(instance)
                ]

    log.info('Finished retrieving data')
    return instances

def parse_solve_message(msg):
    msg = msg.split('\n')[1]
    msg = msg.split(' ' )[0]
    return int(msg)

def runsolver(log, form, instances):
    with Progress() as pbar:
        pbartask = pbar.add_task(
            'Running the solver...',
            len(models[form])*len(numsitems)*len(percpreferred)*numinstances
        )
        
        results = []
        for model in models[form]:
            model_res = []
            for numitems in numsitems:
                numitems_res = []
                for perc in percpreferred:
                    perc_res = []
                    for instance in instances[numitems][perc]:
                        ampl.reset()
                        ampl.read     (model)
                        ampl.read_data(instance)
                        time = timeit.timeit(
                            stmt  =lambda: ampl.eval('solve > /dev/null;'),
                            number=1
                        )
                        pbar.update(pbartask, advance=1)

                        nodes = parse_solve_message(ampl.get_value('solve_message'))
                        sol   =                     ampl.get_value('Gains')

                        instance_desc = pathlib.Path(instance)
                        instance_desc = instance_desc.stem
                        perc_res += [(instance_desc, [nodes, time, sol])]
                    numitems_res += [(perc, perc_res)]
                model_res += [(numitems, numitems_res)]
            model_desc = pathlib.Path(model)
            model_desc = model_desc.stem
            results += [(model_desc, model_res)]
        pbar.stop_task(pbartask)

    log.info('All problem instances executed')

    return results

def printrawresults(log, form, datadir, results):
    path  = pathlib.Path('results') / form
    if not path.is_dir():
        path.mkdir()
    path /= datadir
    path.mkdir()

    with open(path / 'raw-output.csv', 'w') as fd:
        writer = csv.DictWriter(
            f         =fd,
            fieldnames=[
                'model', 'numitems', 'perc', 'instance',
                'nodes', 'time',     'sol']
        )

        writer.writeheader()
        for model, model_res in results:
            for numitems, numitems_res in model_res:
                for perc, perc_res in numitems_res:
                    for instance, (nodes, time, sol) in perc_res:
                        writer.writerow({
                            'model':    model,
                            'numitems': numitems,
                            'perc':     perc,
                            'instance': instance,
                            'nodes':    nodes,
                            'time':     time,
                            'sol':      sol,
                        })

    log.info('Printed raw results')


def printlatexheading(put, results):
    put('% Table for efsll\n')
    put('\n')
    put('\\begin{tabularx}{\\textwidth}{ll *{6}{Y}}\n')
    put('    \\toprule\n')
    put('    $|I|$ & $|S^k|$\n')
    put('        ')
    for model, _ in results:
        put('& \\multicolumn{3}{l}{%s}' % latex_model_name[model])
    put('\\\\\n')
    put(' ' * 3)
    for idx, _ in enumerate(results):
        put(' \\cmidrule(lr){%s-%s}' % ((idx+1)*3, (idx+1)*3+2))
    put('\n')
    put('    &')
    for _ in enumerate(results):
        put(' & Nodes & Time (s) & Sol')
    put('\\\\\n')
    put('    \\midrule\n')

def printlatexbody(put, results):
    for idx, numitems in enumerate(numsitems):
        if idx > 0:
            put('    \\addlinespace\n')
        for pdx, perc in enumerate(percpreferred):
            put('    %d & %d' % (
                numitems,
                math.ceil(numitems*float(perc)/100)))
            for _, model_res in results:
                _, numitems_res = model_res   [idx]
                _, perc_res     = numitems_res[pdx]
                
                nodes = 0
                time  = 0
                sol   = 0
                for _, (n, t, _) in perc_res:
                    nodes += n
                    time  += t
                    if t < TIME_LIMIT:
                        sol += 1
                nodes = int(nodes/len(perc_res))
                time  =     time /len(perc_res)

                put(' & %d & %.1f & %d' % (nodes, time, sol))
            put('\\\\\n')

def printlatexbottom(put, results):
    put('    \\bottomrule\n')
    put('\\end{tabularx}\n')

def printlatextables(log, form, datadir, results):
    path = pathlib.Path('results') / form / datadir

    with open(path / 'tbl-efsll.tex', 'w') as fd:
        def put(s):
            print(s, end='', file=fd)
        printlatexheading(put, results)
        printlatexbody   (put, results)
        printlatexbottom (put, results)
    log.info('Printed latex tables')

def printplots(log, form, datadir, results):
    log.info('Printed plots')

def getlogger():
    logging.basicConfig(
        level="NOTSET",
        format="%(message)s",
        datefmt="[%X]",
        handlers=[
            RichHandler(rich_tracebacks=True)
        ]
    )

    return logging.getLogger("rich")
if __name__ == '__main__':
    log           = getlogger()
    ampl          = getampl  ()
    form, datadir = parseargs()
    instances     = getdata  (log, form, datadir)
    
    results = runsolver(log, form, instances)
    print(results)

    printrawresults (log, form, datadir, results)
    printlatextables(log, form, datadir, results)
    printplots      (log, form, datadir, results)
